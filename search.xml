<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>循环遍历：for in &amp; foreach &amp; while &amp; map</title>
    <url>/2020/loop/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>midi-keyboard</title>
    <url>/2020/midi-keyboard/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Windows</tag>
        <tag>Music</tag>
        <tag>Node.js</tag>
        <tag>Electron</tag>
        <tag>MIDI</tag>
      </tags>
  </entry>
  <entry>
    <title>键盘 keyCode 对照表</title>
    <url>/2020/keycode/</url>
    <content><![CDATA[<style>
table tr td:nth-of-type(2n-1){
  background:#fbfbfb
}
</style>

<h2 id="字母数字键键码值"><a href="#字母数字键键码值" class="headerlink" title="字母数字键键码值"></a>字母数字键键码值</h2><table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">键码</th>
<th align="center">按键</th>
<th align="center">键码</th>
<th align="center">按键</th>
<th align="center">键码</th>
<th align="center">按键</th>
<th align="center">键码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">65</td>
<td align="center">J</td>
<td align="center">74</td>
<td align="center">S</td>
<td align="center">83</td>
<td align="center">1</td>
<td align="center">49</td>
</tr>
<tr>
<td align="center">B</td>
<td align="center">66</td>
<td align="center">K</td>
<td align="center">75</td>
<td align="center">T</td>
<td align="center">84</td>
<td align="center">2</td>
<td align="center">50</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">67</td>
<td align="center">L</td>
<td align="center">76</td>
<td align="center">U</td>
<td align="center">85</td>
<td align="center">3</td>
<td align="center">51</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">68</td>
<td align="center">M</td>
<td align="center">77</td>
<td align="center">V</td>
<td align="center">86</td>
<td align="center">4</td>
<td align="center">52</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">69</td>
<td align="center">N</td>
<td align="center">78</td>
<td align="center">W</td>
<td align="center">87</td>
<td align="center">5</td>
<td align="center">53</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">70</td>
<td align="center">O</td>
<td align="center">79</td>
<td align="center">X</td>
<td align="center">88</td>
<td align="center">6</td>
<td align="center">54</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">71</td>
<td align="center">P</td>
<td align="center">80</td>
<td align="center">Y</td>
<td align="center">89</td>
<td align="center">7</td>
<td align="center">55</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">72</td>
<td align="center">Q</td>
<td align="center">81</td>
<td align="center">Z</td>
<td align="center">90</td>
<td align="center">8</td>
<td align="center">56</td>
</tr>
<tr>
<td align="center">I</td>
<td align="center">73</td>
<td align="center">R</td>
<td align="center">82</td>
<td align="center">0</td>
<td align="center">48</td>
<td align="center">9</td>
<td align="center">57</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="数字键盘键码值"><a href="#数字键盘键码值" class="headerlink" title="数字键盘键码值"></a>数字键盘键码值</h2><table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">键码</th>
<th align="center">按键</th>
<th align="center">键码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">96</td>
<td align="center">8</td>
<td align="center">104</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">97</td>
<td align="center">9</td>
<td align="center">105</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">98</td>
<td align="center">*</td>
<td align="center">106</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">99</td>
<td align="center">+</td>
<td align="center">107</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">100</td>
<td align="center">Enter</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">101</td>
<td align="center">-</td>
<td align="center">109</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">102</td>
<td align="center">.</td>
<td align="center">110</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">103</td>
<td align="center">/</td>
<td align="center">111</td>
</tr>
</tbody></table>
<h2 id="功能键键码值"><a href="#功能键键码值" class="headerlink" title="功能键键码值"></a>功能键键码值</h2><table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">键码</th>
<th align="center">按键</th>
<th align="center">键码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">F1</td>
<td align="center">112</td>
<td align="center">F7</td>
<td align="center">118</td>
</tr>
<tr>
<td align="center">F2</td>
<td align="center">113</td>
<td align="center">F8</td>
<td align="center">119</td>
</tr>
<tr>
<td align="center">F3</td>
<td align="center">114</td>
<td align="center">F9</td>
<td align="center">120</td>
</tr>
<tr>
<td align="center">F4</td>
<td align="center">115</td>
<td align="center">F10</td>
<td align="center">121</td>
</tr>
<tr>
<td align="center">F5</td>
<td align="center">116</td>
<td align="center">F11</td>
<td align="center">122</td>
</tr>
<tr>
<td align="center">F6</td>
<td align="center">117</td>
<td align="center">F12</td>
<td align="center">123</td>
</tr>
</tbody></table>
<h2 id="控制键键码值"><a href="#控制键键码值" class="headerlink" title="控制键键码值"></a>控制键键码值</h2><table>
<thead>
<tr>
<th align="center">按键</th>
<th align="center">键码</th>
<th align="center">按键</th>
<th align="center">键码</th>
<th align="center">按键</th>
<th align="center">键码</th>
<th align="center">按键</th>
<th align="center">键码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">BackSpace</td>
<td align="center">8</td>
<td align="center">Esc</td>
<td align="center">27</td>
<td align="center">Right Arrow</td>
<td align="center">39</td>
<td align="center">-_</td>
<td align="center">189</td>
</tr>
<tr>
<td align="center">Tab</td>
<td align="center">9</td>
<td align="center">Spacebar</td>
<td align="center">32</td>
<td align="center">Dw Arrow</td>
<td align="center">40</td>
<td align="center">.&gt;</td>
<td align="center">190</td>
</tr>
<tr>
<td align="center">Clear</td>
<td align="center">12</td>
<td align="center">Page Up</td>
<td align="center">33</td>
<td align="center">Insert</td>
<td align="center">45</td>
<td align="center">/?</td>
<td align="center">191</td>
</tr>
<tr>
<td align="center">Enter</td>
<td align="center">13</td>
<td align="center">Page Down</td>
<td align="center">34</td>
<td align="center">Delete</td>
<td align="center">46</td>
<td align="center">`~</td>
<td align="center">192</td>
</tr>
<tr>
<td align="center">Shift</td>
<td align="center">16</td>
<td align="center">End</td>
<td align="center">35</td>
<td align="center">Num Lock</td>
<td align="center">144</td>
<td align="center">[{</td>
<td align="center">219</td>
</tr>
<tr>
<td align="center">Control</td>
<td align="center">17</td>
<td align="center">Home</td>
<td align="center">36</td>
<td align="center">;:</td>
<td align="center">186</td>
<td align="center">╲┆</td>
<td align="center">220</td>
</tr>
<tr>
<td align="center">Alt</td>
<td align="center">18</td>
<td align="center">Left Arrow</td>
<td align="center">37</td>
<td align="center">=+</td>
<td align="center">187</td>
<td align="center">]}</td>
<td align="center">221</td>
</tr>
<tr>
<td align="center">Cape Lock</td>
<td align="center">20</td>
<td align="center">Up Arrow</td>
<td align="center">38</td>
<td align="center">,&lt;</td>
<td align="center">188</td>
<td align="center">‘“</td>
<td align="center">222</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>keyboard</tag>
        <tag>keyCode</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式、设计原则和反模式</title>
    <url>/2020/anti-patterns/</url>
    <content><![CDATA[<h2 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1. 设计模式"></a>1. 设计模式</h2><h3 id="1-1-什么是设计模式？"><a href="#1-1-什么是设计模式？" class="headerlink" title="1.1 什么是设计模式？"></a>1.1 什么是设计模式？</h3><p>模式是在某种情境下，针对某种问题的某种解决方案。<br>设计模式算是一种经验复用。</p>
<h3 id="1-2-为什么要使用设计模式？"><a href="#1-2-为什么要使用设计模式？" class="headerlink" title="1.2 为什么要使用设计模式？"></a>1.2 为什么要使用设计模式？</h3><ol>
<li><p>开发小组不需要重新设计解决方案来解决已经被前人解决过的问题。如此可以节省很多设计开发时间。</p>
</li>
<li><p>当开发小组讨论设计的时候，使用设计模式可以使大家更好了理解问题所在和解决方案，而且对解决方案有一个比较统一的认知。</p>
</li>
<li><p>设计模式本身已经通过了大量的实际运用和验证，其设计质量和实用价值有很好的保证。</p>
</li>
<li><p>设计模式本身有健全的文档，可以一定程度上简化撰写开发文档。</p>
</li>
</ol>
<a id="more"></a>

<h2 id="2-设计模式的分类"><a href="#2-设计模式的分类" class="headerlink" title="2. 设计模式的分类"></a>2. 设计模式的分类</h2><h3 id="2-1-创建型"><a href="#2-1-创建型" class="headerlink" title="2.1. 创建型"></a>2.1. 创建型</h3><p>涉及到将对象实例化。</p>
<p>如：单例模式，工厂模式 </p>
<h3 id="2-2-结构型"><a href="#2-2-结构型" class="headerlink" title="2.2. 结构型"></a>2.2. 结构型</h3><p>把类或对象组合到更大的结构中。 </p>
<p>如：装饰器，代理模式，适配器模式 </p>
<h3 id="2-3-行为型"><a href="#2-3-行为型" class="headerlink" title="2.3. 行为型"></a>2.3. 行为型</h3><p>涉及到类和对象如何交互及分配职责。 </p>
<p>模板方法，观察者模式，策略模式</p>
<h2 id="3-什么是设计原则"><a href="#3-什么是设计原则" class="headerlink" title="3. 什么是设计原则"></a>3. 什么是设计原则</h2><h3 id="3-1-封装变化"><a href="#3-1-封装变化" class="headerlink" title="3.1. 封装变化"></a>3.1. 封装变化</h3><p>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起 </p>
<h3 id="3-2-针对接口编程"><a href="#3-2-针对接口编程" class="headerlink" title="3.2. 针对接口编程"></a>3.2. 针对接口编程</h3><p>针对接口编程，而不是针对实现编程。此处的接口是指超类型，针对接口编程的意思是利用多态的能力，使得实际的类型可以动态绑定到真正需要的实现上。 </p>
<h3 id="3-3-多用组合"><a href="#3-3-多用组合" class="headerlink" title="3.3. 多用组合"></a>3.3. 多用组合</h3><p>多用组合，少用继承。组合比继承更灵活。 </p>
<h3 id="3-4-松耦合设计"><a href="#3-4-松耦合设计" class="headerlink" title="3.4. 松耦合设计"></a>3.4. 松耦合设计</h3><p>为了交互对象之间的松耦合设计而努力。这样会使我们的系统更有弹性，在应对新的需求时，由于对象之间的相互依赖降低到最低，从而需要修改的量最小。 </p>
<h3 id="3-5-开闭原则"><a href="#3-5-开闭原则" class="headerlink" title="3.5. 开闭原则"></a>3.5. 开闭原则</h3><p>开闭原则：类应该对扩展开放，对修改关闭。意思是在不修改现有类的代码情况下，扩展类可以满足新的需求。因为已有代码是精心设计的，修改容易产生BUG，而且精心设计的代码，是易于扩展的。 </p>
<h3 id="3-6-依赖导致原则"><a href="#3-6-依赖导致原则" class="headerlink" title="3.6. 依赖导致原则"></a>3.6. 依赖导致原则</h3><p>依赖导致原则：要依赖抽象，不要依赖具体类。 </p>
<h3 id="3-7-最少知识原则"><a href="#3-7-最少知识原则" class="headerlink" title="3.7. 最少知识原则"></a>3.7. 最少知识原则</h3><p>最少知识原则：只和你的密友谈话。减少对象之间的交互。从而将受到影响而导致修改的可能性降到最低。 </p>
<h3 id="3-8-高层级调用"><a href="#3-8-高层级调用" class="headerlink" title="3.8. 高层级调用"></a>3.8. 高层级调用</h3><p>别调用我，我会调用你。这是组合高层组件和低层组件的一种原则。高层组件决定什么时候以及如何调用低层组件。低层组件只是挂在高层组件之下。 </p>
<h3 id="3-9-单一责任原则"><a href="#3-9-单一责任原则" class="headerlink" title="3.9. 单一责任原则"></a>3.9. 单一责任原则</h3><p>对于一个模块，或者一个类来说，这个模块或者这个类应该只对系统/软件的一个功能负责，而且该责任应该被该类完全封装起来。</p>
<h2 id="4-常用的模式类型"><a href="#4-常用的模式类型" class="headerlink" title="4. 常用的模式类型"></a>4. 常用的模式类型</h2><h3 id="4-1-策略模式"><a href="#4-1-策略模式" class="headerlink" title="4.1. 策略模式"></a>4.1. 策略模式</h3><p>定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户。</p>
<h3 id="4-2-观察者模式"><a href="#4-2-观察者模式" class="headerlink" title="4.2. 观察者模式"></a>4.2. 观察者模式</h3><p>定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 </p>
<h3 id="4-3-装饰器模式"><a href="#4-3-装饰器模式" class="headerlink" title="4.3. 装饰器模式"></a>4.3. 装饰器模式</h3><p>动态的将责任附加到对象上，若要扩展功能，装饰器提供了比继承更有弹性的替代方案。 </p>
<h3 id="4-4-工厂模式"><a href="#4-4-工厂模式" class="headerlink" title="4.4. 工厂模式"></a>4.4. 工厂模式</h3><p>简单的工厂模式，就是把对象的创建提出来单独处理。而标准的工厂模式，定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。</p>
<p>工厂方法让类把实例化推迟到子类。 </p>
<h3 id="4-5-抽象工厂模式"><a href="#4-5-抽象工厂模式" class="headerlink" title="4.5. 抽象工厂模式"></a>4.5. 抽象工厂模式</h3><p>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确确定具体类。 </p>
<h3 id="4-6-单例模式"><a href="#4-6-单例模式" class="headerlink" title="4.6. 单例模式"></a>4.6. 单例模式</h3><p>确保一个类只有一个实例，并提供一个全局访问点。 </p>
<h3 id="4-7-命令模式"><a href="#4-7-命令模式" class="headerlink" title="4.7. 命令模式"></a>4.7. 命令模式</h3><p>将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其它对象。</p>
<p>命令模式也支持可撤销的操作。 </p>
<h3 id="4-8-适配器模式"><a href="#4-8-适配器模式" class="headerlink" title="4.8. 适配器模式"></a>4.8. 适配器模式</h3><p>将一个类的接口，转换成客户期望的另一个接口。</p>
<p>适配器让原本接口不兼容的类可以合作无间。 </p>
<h3 id="4-9-外观模式"><a href="#4-9-外观模式" class="headerlink" title="4.9. 外观模式"></a>4.9. 外观模式</h3><p>提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 </p>
<h3 id="4-10-模板方法模式"><a href="#4-10-模板方法模式" class="headerlink" title="4.10. 模板方法模式"></a>4.10. 模板方法模式</h3><p>在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。</p>
<p>模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。 </p>
<h3 id="4-11-迭代器模式"><a href="#4-11-迭代器模式" class="headerlink" title="4.11. 迭代器模式"></a>4.11. 迭代器模式</h3><p>提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。 </p>
<h3 id="4-12-组合模式"><a href="#4-12-组合模式" class="headerlink" title="4.12. 组合模式"></a>4.12. 组合模式</h3><p>允许你将对象组合成树形结构来表现『整体/部分』层次结构。</p>
<p>组合能让客户以一致的方式处理个别对象以及对象组合。 </p>
<h3 id="4-13-状态模式"><a href="#4-13-状态模式" class="headerlink" title="4.13. 状态模式"></a>4.13. 状态模式</h3><p>允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 </p>
<h3 id="4-14-代理模式"><a href="#4-14-代理模式" class="headerlink" title="4.14. 代理模式"></a>4.14. 代理模式</h3><p>为另一个对象提供一个替身或占位符以访问这个对象。</p>
<h2 id="5-反模式"><a href="#5-反模式" class="headerlink" title="5. 反模式"></a>5. 反模式</h2><h3 id="5-1-什么是反模式"><a href="#5-1-什么是反模式" class="headerlink" title="5.1 什么是反模式"></a>5.1 什么是反模式</h3><p>反模式是指在对经常面对的问题经常使用的低效、不良、或者有待优化的设计模式/方法。甚至，反模式也可以是一种错误的开发思想/理念。</p>
<h3 id="5-2-常见的反模式案例"><a href="#5-2-常见的反模式案例" class="headerlink" title="5.2. 常见的反模式案例"></a>5.2. 常见的反模式案例</h3><p><strong>软件膨胀</strong>：随着版本的升级，软件越来越消耗系统资源。</p>
<p><strong>反抽象</strong>：需要的功能并不暴露给用户，导致用户要在较高层次重新实现一些功能。</p>
<p><strong>万能类</strong>︰在一个类的设计中，聚集了太多的函数。</p>
<p><strong>硬编码(Hard Code)</strong>：或称写死。在实现某系统用途上设死该系统的运作环境。</p>
<p><strong>超布尔逻辑</strong>︰不必要的比较，或是过于抽象的布尔计算。</p>
<p><strong>剪贴编程(Copy-n-paste programming)</strong>：宁愿拷贝(并修改)现存代码而非创造通用的解决方案。</p>
<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><ol>
<li><a href="http://zh.wikipedia.org/wiki/%E5%8F%8D%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">反模式wiki</a></li>
</ol>
]]></content>
      <categories>
        <category>编程术语</category>
      </categories>
      <tags>
        <tag>反模式</tag>
        <tag>设计模式</tag>
        <tag>设计原则</tag>
      </tags>
  </entry>
  <entry>
    <title>Canvas</title>
    <url>/2020/canvas/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>canvas 元素可被用来通过 JavaScript（Canvas API 或 WebGL API）绘制图形及图形动画。</p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><strong>width</strong>：该元素占用空间的宽度，以 CSS 像素（px）表示，默认为 300。</p>
<p><strong>height</strong>：该元素占用空间的高度，以 CSS 像素（px）表示，默认为 150。</p>
<h3 id="Canvas-和-SVG-的区别是什么？"><a href="#Canvas-和-SVG-的区别是什么？" class="headerlink" title="Canvas 和 SVG 的区别是什么？"></a>Canvas 和 SVG 的区别是什么？</h3><p>一句话总结：都是 2D 做图，svg 是矢量图，canvas 是位图。</p>
<p>svg 适合用于渲染图标 logo；Canvas 是逐像素进行渲染的，适合用于渲染游戏。</p>
<p><strong>svg</strong>: 一种使用 XML 描述 2D 图形的语言。</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"red"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>canvas</strong>: 由于是位图，当 w 或 h 有小数时，会产生虚边。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"300px"</span> <span class="attr">height</span>=<span class="string">"100px"</span>&gt;</span> <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>)</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span></span><br><span class="line"><span class="actionscript">  ctx.fillStyle = <span class="string">'red'</span></span></span><br><span class="line">  ctx.fillRect(0, 0, 300, 100)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo1" target="_blank" rel="noopener">查看 demo</a></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo2" target="_blank" rel="noopener">查看 demo</a></p>
<h3 id="1-坐标轴"><a href="#1-坐标轴" class="headerlink" title="1. 坐标轴"></a>1. 坐标轴</h3><p>canvas 的<strong>默认</strong>原点在画布的左上角。x = 0, y = 0。</p>
<p>X 轴向右延伸，Y 轴向下延伸。在 canvas 中顺时针为正，逆时针为负。</p>
<p><img src="/images/canvas/coordinate.png" alt=""></p>
<p>改变 Y 轴方向：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改变Y轴方向</span></span><br><span class="line">context.translate(<span class="number">0</span>, offsetY)</span><br><span class="line">context.scale(<span class="number">1</span>, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/images/canvas/coordinate2.png" alt=""></p>
<h3 id="2-HTMLCanvasElement"><a href="#2-HTMLCanvasElement" class="headerlink" title="2. HTMLCanvasElement"></a>2. HTMLCanvasElement</h3><p>DOM canvas 元素暴露了 <strong>HTMLCanvasElement</strong> 接口,该接口提供了用来操作一个 <strong>canvas</strong> 元素布局和呈现的属性和方法。HTMLCanvasElement 接口继承了 element 接口的属性和方法。</p>
<ul>
<li><p><code>HTMLCanvasElement.width</code> canvas 元素在 html 文档中的宽度</p>
</li>
<li><p><code>HTMLCanvasElement.height</code> canvas 元素在 html 文档中的高度</p>
</li>
</ul>
<h3 id="3-canvas-toDataURL"><a href="#3-canvas-toDataURL" class="headerlink" title="3. canvas.toDataURL()"></a>3. canvas.toDataURL()</h3><ul>
<li>如果画布的高度或宽度是 0，那么会返回字符串“data:,”。</li>
<li>如果传入的类型非“image/png”，但是返回的值以“data:image/png”开头，那么该传入的类型是不支持的。</li>
<li>Chrome 支持“image/webp”类型。</li>
</ul>
<h4 id="3-1-Data-URLs"><a href="#3-1-Data-URLs" class="headerlink" title="3.1. Data URLs"></a>3.1. Data URLs</h4><p>即前缀为 data: 协议的 URL，其允许内容创建者向文档中嵌入小文件。</p>
<p>Data URLs 由四个部分组成：前缀(data:)、指示数据类型的 MIME 类型、如果非文本则为可选的 base64 标记、数据本身：</p>
<p><code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></p>
<p>mediatype 是个 MIME 类型的字符串，例如 “image/jpeg” 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII</p>
<p>如果数据是文本类型，你可以直接将文本嵌入 (根据文档类型，使用合适的实体字符或转义字符)。如果是二进制数据，你可以将数据进行 base64 编码之后再进行嵌入。</p>
<p>下面是一些示例：</p>
<ol>
<li><p>简单的 text/plain 类型数据</p>
<p><code>data:,Hello%2C%20World!</code></p>
</li>
<li><p>上一条示例的 base64 编码版本</p>
<p><code>data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D</code></p>
</li>
<li><p>一个 HTML 文档源代码 <code>&lt;h1&gt;Hello, World&lt;/h1&gt;</code></p>
<p><code>data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E</code></p>
</li>
<li><p>一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。</p>
<p><code>data:text/html,&lt;script&gt;alert(&#39;hi&#39;);&lt;/script&gt;</code></p>
</li>
</ol>
<h4 id="3-2-语法"><a href="#3-2-语法" class="headerlink" title="3.2. 语法"></a>3.2. 语法</h4><ul>
<li><p><code>canvas.toDataURL(type, encoderOptions)</code> 返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为 96dpi。</p>
<p><strong>type</strong>: 可选, 图片格式，默认为 image/png。</p>
<p><strong>encoderOptions</strong>： 可选，在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略。</p>
</li>
</ul>
<h3 id="4-canvas-toBlob"><a href="#4-canvas-toBlob" class="headerlink" title="4. canvas.toBlob()"></a>4. canvas.toBlob()</h3><p>创造 Blob 对象，用以展示 canvas 上的图片；这个图片文件可以被缓存或保存到本地，由用户代理端自行决定。如不特别指明，图片的类型默认为 image/png，分辨率为 96dpi。第三个参数用于针对 image/jpeg 格式的图片进行输出图片的质量设置。</p>
<h4 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4.1. 语法"></a>4.1. 语法</h4><ul>
<li><code>canvas.toBlob(callback, type, encoderOptions)</code></li>
</ul>
<p><strong>callback</strong>：回调函数，可获得一个单独的 Blob 对象参数。</p>
<p><strong>type</strong>： 可选，DOMString 类型，指定图片格式，默认格式为 image/png。</p>
<p><strong>encoderOptions</strong>： 可选，Number 类型，值在 0 与 1 之间，当请求图片格式为 image/jpeg 或者 image/webp 时用来指定图片展示质量。如果这个参数的值不在指定类型与范围之内，则使用默认值，其余参数将被忽略。</p>
<h3 id="5-canvas-getContext"><a href="#5-canvas-getContext" class="headerlink" title="5. canvas.getContext()"></a>5. canvas.getContext()</h3><p><code>canvas.getContext()</code> 方法返回 canvas 的上下文，如果上下文没有定义则返回 null。在同一个 canvas 上以相同的 contextType 多次调用此方法只会返回同一个上下文。</p>
<p>当我们想要实现一些 ctx 目前没有的方法和属性时，我们可以通过 <strong>ctx.prototype</strong> 增加新的自定义属性和方法。即<code>ctx.prototype.新属性</code>、<code>ctx.prototype.新方法</code>。注意自定义的新属性和新方法不能和原生的重名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加新属性, 角度 1° 的值</span></span><br><span class="line">ctx.prototype.angleValue = <span class="built_in">Math</span>.PI / <span class="number">180</span></span><br><span class="line"><span class="comment">// 增加新方法，清空画布</span></span><br><span class="line">ctx.prototype.clearCanvas(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// to do Something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(contextType)</span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(contextType, contextAttributes)</span><br></pre></td></tr></table></figure>

<h5 id="contextType"><a href="#contextType" class="headerlink" title="contextType"></a>contextType</h5><ul>
<li><p>‘2d’： 二维平面效果渲染</p>
</li>
<li><p>‘webgl’：三维立体效果渲染</p>
</li>
<li><p>‘bitmaprenderer’：<code>TODO:!暂时未知使用方法!</code></p>
</li>
</ul>
<h5 id="contextAttributes"><a href="#contextAttributes" class="headerlink" title="contextAttributes"></a>contextAttributes</h5><p><code>ctxType = &#39;2d&#39;</code>:</p>
<ul>
<li><strong>alpha</strong>: boolean 值表明 canvas 包含一个 alpha 通道. 如果设置为 false, 浏览器将认为 canvas 背景总是不透明的, 这样可以加速绘制透明的内容和图片.</li>
</ul>
<p><code>ctxType = &#39;webgl&#39;</code>:</p>
<ul>
<li><p><strong>alpha</strong>: boolean 值表明 canvas 包含一个 alpha 缓冲区。</p>
</li>
<li><p><strong>antialias</strong>: boolean 值表明是否开启抗锯齿。</p>
</li>
<li><p><strong>depth</strong>: boolean 值表明绘制缓冲区包含一个深度至少为 16 位的缓冲区。</p>
</li>
<li><p><strong>failIfMajorPerformanceCaveat</strong>: 表明在一个系统性能低的环境是否创建该上下文的 boolean 值。</p>
</li>
<li><p><strong>powerPreference</strong>: 指示浏览器在运行 WebGL 上下文时使用相应的 GPU 电源配置。”default”:自动选择，默认值。”high-performance”: 高性能模式。”low-power”: 节能模式。</p>
</li>
<li><p><strong>premultipliedAlpha</strong>: 表明排版引擎讲假设绘制缓冲区包含预混合 alpha 通道的 boolean 值。</p>
</li>
<li><p><strong>preserveDrawingBuffer</strong>: 如果这个值为 true 缓冲区将不会被清除，会保存下来，直到被清除或被使用者覆盖。</p>
</li>
<li><p><strong>stencil</strong>: 表明绘制缓冲区包含一个深度至少为 8 位的模版缓冲区 boolean 值。</p>
</li>
</ul>
<h2 id="绘图方法"><a href="#绘图方法" class="headerlink" title="绘图方法"></a>绘图方法</h2><h3 id="1-1-设置绘图环境和样式"><a href="#1-1-设置绘图环境和样式" class="headerlink" title="1.1. 设置绘图环境和样式"></a>1.1. 设置绘图环境和样式</h3><ul>
<li><code>ctx.canvas</code> 上下文关联的 HTMLCanvasElement 对象。如果没有 <code>&lt;canvas&gt;</code> 元素与之对应，对象值为 null 。可以使用<code>ctx.canvas.width</code>来获取 canvas 宽度，或者<code>ctx.canvas.width=&#39;500px&#39;</code>来重设新置 canvas 宽度。</li>
</ul>
<h4 id="1-1-1-设置填充和描边颜色"><a href="#1-1-1-设置填充和描边颜色" class="headerlink" title="1.1.1. 设置填充和描边颜色"></a>1.1.1. 设置填充和描边颜色</h4><ul>
<li><p><code>ctx.fillStyle</code> 设置填充颜色, 接受三种类型参数：color（颜色字符串）、gradient（渐变对象）、pattern（图案对象）</p>
</li>
<li><p><code>ctx.strokeStyle</code> 设置描边颜色，接受三种类型参数，同上。</p>
</li>
</ul>
<h4 id="1-1-2-设置线型样式"><a href="#1-1-2-设置线型样式" class="headerlink" title="1.1.2. 设置线型样式"></a>1.1.2. 设置线型样式</h4><ul>
<li><p><code>ctx.lineCap</code> 线段端点的样式类型 <code>butt</code>方形(默认)、<code>round</code>圆形（半径是线段的宽度）、<code>square</code>矩形（高度是线段厚度一半的）</p>
</li>
<li><p><code>ctx.lineJoin</code> 线段拐角的样式类型 <code>miter</code>尖角(默认)、<code>round</code>圆角（半径是线段的宽度）、<code>bevel</code>平角</p>
</li>
<li><p><code>ctx.lineWidth</code> 设置线条宽度，默认对齐方式为居中对齐，默认为 1px</p>
<p>线宽对齐方式参考 PS：</p>
<p><img src="/images/canvas/line_style.jpg" alt=""></p>
</li>
<li><p><code>ctx.miterLimit</code> 斜接面限制比例的的数字。 0、负数、Infinity 和 NaN 都会被忽略。只当 <code>ctx.lineJoin=&#39;miter&#39;</code>时才有效。</p>
</li>
</ul>
<h4 id="1-1-3-设置字体和文字对齐"><a href="#1-1-3-设置字体和文字对齐" class="headerlink" title="1.1.3. 设置字体和文字对齐"></a>1.1.3. 设置字体和文字对齐</h4><ul>
<li><p><code>ctx.font</code> 设置文本样式，参数参考 css font 属性。如：<code>ctx.font = &#39;10px sans-serif&#39;</code></p>
</li>
<li><p><code>ctx.textAlign</code> 设置文本对齐方式，”left” || “right” || “center” || “start”（默认） || “end”。当设置为”center”时，fillText 的 xy 值为中点。</p>
</li>
<li><p><code>ctx.textBaseline</code> 设置文本的基线对齐方式（垂直方向），”top” || “hanging” || “middle” || “alphabetic”（默认） || “ideographic” || “bottom”。</p>
</li>
</ul>
<h4 id="1-1-4-设置阴影样式"><a href="#1-1-4-设置阴影样式" class="headerlink" title="1.1.4. 设置阴影样式"></a>1.1.4. 设置阴影样式</h4><ul>
<li><p><code>ctx.shadowColor</code> 设置阴影颜色，只能接受 color 类型的颜色字符串。注意，阴影颜色可以通过颜色类型 rgba 或 hsla 设置阴影的透明度，但当透明度完全为 0 时，阴影不会被绘制。</p>
</li>
<li><p><code>ctx.shadowBlur</code> 设置阴影模糊程度，默认为 0。float 类型，即负数、 Infinity 或者 NaN 都会被忽略。当 blur = 0，且 offsetX 或 offsetY 的值不为 0 时，阴影仍然会被绘制，只是没有模糊效果。</p>
</li>
<li><p><code>ctx.shadowOffsetX</code> 设置阴影水平偏移距离，默认为 0。float 类型。</p>
</li>
<li><p><code>ctx.shadowOffsetY</code> 设置阴影垂直偏移距离，默认为 0。float 类型。</p>
</li>
</ul>
<h4 id="1-1-5-设置全局透明度"><a href="#1-1-5-设置全局透明度" class="headerlink" title="1.1.5. 设置全局透明度"></a>1.1.5. 设置全局透明度</h4><ul>
<li><code>ctx.globalAlpha</code> 设置图形和图片透明度的属性。 数值的范围从 0.0 （完全透明）到 1.0 （完全不透明）。 默认值是 1.0。 如果数值不在范围内，包括 Infinity 和 NaN ，无法赋值，并且 globalAlpha 会保持原有的数值。</li>
</ul>
<h4 id="1-1-6-设置图层混合模式"><a href="#1-1-6-设置图层混合模式" class="headerlink" title="1.1.6. 设置图层混合模式"></a>1.1.6. 设置图层混合模式</h4><ul>
<li><p><code>ctx.globalCompositeOperation</code> 设置合成操作的类型。类型可选：source-over、source-in、source-out、source-atop、destination-over、destination-in、destination-out、destination-atop、lighter、copy、xor（差集）、multiply、screen、overlay、darken、lighten、color-dodge、color-burn、hard-light、soft-light、difference、exclusion、hue、saturation、color、luminosity。可理解为 PS 中的图层混合模式 + AI 中的路径查找器。</p>
<p><img src="/images/canvas/composite.png" alt=""></p>
</li>
</ul>
<h4 id="1-1-7-设置图案样式"><a href="#1-1-7-设置图案样式" class="headerlink" title="1.1.7. 设置图案样式"></a>1.1.7. 设置图案样式</h4><ul>
<li><p><code>ctx.createPattern(image, repetition)</code> 根据传入的图片，创建一个可重复的图案。返回 <strong>CanvasPattern</strong> 对象，不透明。创建完成后，可以使用 <code>CanvasPattern.setTransform()</code>方法对图案进行变形。</p>
<p><strong>image</strong>：作为重复图像源的 <strong>CanvasImageSource</strong> 对象。可以是下列之一</p>
<ul>
<li>HTMLImageElement (<code>&lt;img&gt;</code>),</li>
<li>HTMLVideoElement (<code>&lt;video&gt;</code>),</li>
<li>HTMLCanvasElement (<code>&lt;canvas&gt;</code>),</li>
<li>CanvasRenderingContext2D,</li>
<li>ImageBitmap,</li>
<li>ImageData,</li>
<li>Blob.</li>
</ul>
<p><strong>repetition</strong>：DOMString，指定如何重复图像。如果为空字符串 (‘’) 或 null (但不是 undefined)，repetition 将被当作”repeat”。允许的值有：</p>
<ul>
<li>“repeat” (both directions),</li>
<li>“repeat-x” (horizontal only),</li>
<li>“repeat-y” (vertical only),</li>
<li>“no-repeat” (neither).</li>
</ul>
</li>
<li><p><code>pattern.setTransform(matrix)</code> 使用 SVGMatrix 对象作为图案的变换矩阵，并在此图案上调用它。</p>
</li>
</ul>
<h4 id="1-1-8-设置渐变样式"><a href="#1-1-8-设置渐变样式" class="headerlink" title="1.1.8. 设置渐变样式"></a>1.1.8. 设置渐变样式</h4><ul>
<li><p><code>ctx.createLinearGradient(x0, y0, x1, y1)</code> 创建一个沿参数坐标指定的直线的渐变。起点（x0, y0），终点（x1, y1）。返回 <strong>CanvasGradient</strong> 对象。<br>改变线性渐变的方向有两种方式：1️⃣ 调换 addColorStop 0 和 1 对应的值；2️⃣ 调换 createLinearGradient 创建的起点和终点，即（x1, y1, x0, y0）。<br>我们知道，通过两不同点的直线有且只有一条。所以一般来说，我们只要改变 x0, y0, x1, y1 这四个值就可以轻松的改变渐变方向。这点可以结合 PS 里的线性渐变理解。</p>
<p><img src="/images/canvas/gradient_line.png" alt=""></p>
</li>
</ul>
<p><strong>CanvasGradient</strong> 描述渐变的不透明对象。CanvasGradient 有一个方法：<code>CanvasGradient.addColorStop()</code></p>
<ul>
<li><p><code>CanvasGradient.addColorStop(offset, color)</code> 添加一个由偏移值和颜色值指定的断点到渐变。offset: 0 到 1 之间的值，超出范围将抛出 INDEX_SIZE_ERR 错误; color: CSS 颜色值 <code>&lt;color&gt;</code>。如果颜色值不能被解析为有效的 CSS 颜色值 <code>&lt;color&gt;</code>，将抛出 SYNTAX_ERR 错误。</p>
</li>
<li><p><code>ctx.createRadialGradient(x0, y0, r0, x1, y1, r1)</code> 根据参数确定两个圆的坐标，绘制放射性渐变。起点圆，圆心(x0, y0)，半径（r0）; 结束圆，圆心(x1, y1)，半径（r1）。返回<strong>CanvasGradient</strong>对象。</p>
<p>注意: 1️⃣ 当两个圆的半径相同时，r0 = r1 时，渐变不可见。2️⃣ 当两个圆的圆心坐标不同时，渐变效果则无法填充满路径。</p>
</li>
</ul>
<h3 id="1-2-绘制矩形"><a href="#1-2-绘制矩形" class="headerlink" title="1.2. 绘制矩形"></a>1.2. 绘制矩形</h3><ul>
<li><p><code>ctx.clearRect(x, y, w, h)</code> 绘制一个起点在 (x, y) 、宽度为 w 、高度为 h 的透明矩形，此矩形将擦除所在区域的所有内容。</p>
</li>
<li><p><code>ctx.fillRect(x, y, w, h)</code> 绘制一个起点在 (x, y) 、宽度为 w 、高度为 h 的实心矩形。</p>
</li>
<li><p><code>ctx.strokeRect(x, y, w, h)</code> 绘制一个起点在 (x, y) 、宽度为 w 、高度为 h 的描边矩形。此方法直接绘制到画布而不会修改当前路径。</p>
</li>
</ul>
<h3 id="1-3-绘制虚线"><a href="#1-3-绘制虚线" class="headerlink" title="1.3. 绘制虚线"></a>1.3. 绘制虚线</h3><ul>
<li><p><code>ctx.setLineDash([length, spacing])</code> 传入一组数组设置线段和间距的值，以绘制虚线。如果数组元素的数量是奇数，数组元素会被复制并重复。如果数组为空，将会变为实线。</p>
</li>
<li><p><code>ctx.getLineDash()</code> 获取当前线段样式，得到一组数组为线段和间距的值，例：[5, 10], 长度为 5px 的线段, 间隔为 10px。</p>
</li>
<li><p><code>ctx.lineDashOffset</code> 设置虚线偏移量，默认 0</p>
</li>
</ul>
<h3 id="1-4-绘制路径"><a href="#1-4-绘制路径" class="headerlink" title="1.4. 绘制路径"></a>1.4. 绘制路径</h3><ul>
<li><p><code>ctx.beginPath()</code> 创建一个新的路径</p>
</li>
<li><p><code>ctx.moveTo()</code> 将笔触起点移动到 (x, y)</p>
</li>
<li><p><code>ctx.closePath()</code> 封闭当前路径，当存在起点和终点，并且图形为封闭时讲创建一个连接起点和终点的直线。</p>
</li>
<li><p><code>ctx.stroke()</code> 给当前路径描边</p>
</li>
<li><p><code>ctx.lineTo(x, y)</code> 绘制一个从起点到指定点 (x, y) 的直线</p>
</li>
<li><p><code>ctx.rect(x, y, w, h)</code> 绘制一个起点在 (x, y) 、宽度为 w 、高度为 h 的矩形路径</p>
</li>
<li><p><code>ctx.fill()</code> 填充当前或已存在的路径，可选传 fillRule, 或选传 (Path2d, fillRule)。</p>
<p><strong>fillRule</strong> 是一种算法，决定点是在路径内还是在路径外。”nonzero”: 非零环绕规则（默认），”evenodd”: 奇偶环绕规则。利用这一特性，我们可以做出非常复杂的镂空图形。</p>
<p><strong>非零环绕填充规则</strong>：如果想知道某一区域是否被填充，就从这一区域画一条直线向外，在与其他线的交点处，如果其他线是顺时针方向画的，就+1，逆时针则-1，如果最后总和为 0，则不会填充，非零则填充。</p>
<p><img src="/images/canvas/fillrule.png" alt=""></p>
<p><strong>奇偶环绕填充规则</strong>：在路径包围的区域中，随便找一点，向外发射一条射线，和所有围绕它的边相交，查看相交线的个数，如果为奇数，就填充，如果是偶数，就不填充。</p>
<p><strong>path2D()</strong> 转换 svg 格式的路径, 用法见 demo <a href="https://gaofanghuang.github.io/demo/api/canvas/demo1" target="_blank" rel="noopener">查看 demo</a></p>
</li>
<li><p><code>ctx.stroke()</code> 给当前或已经存在的路径创建描边</p>
</li>
<li><p><code>ctx.drawFocusIfNeeded(element)</code> 如果传入的元素是聚焦的，就给当前路径绘制焦点。也可传入(path, element)。 注意该元素必须写在 canvas 标签内。(这个 api 不知道有什么应用场景，因为写在 canvas 里的标签是不可见也不可点击的，感觉这个 api 是多余的)</p>
</li>
<li><p><code>ctx.clip()</code> 将当前创建的路径设置为当前剪切路径，之后创建的所有信息都只会出现在此路径内部。可选传 fillRule, 或选传 (Path2d, fillRule)。</p>
</li>
<li><p><code>ctx.isPointInPath(x, y, fillRule)</code> 判断当前路径内部是否包含指定的点</p>
</li>
<li><p><code>ctx.isPointInStroke(x, y)</code> 判断当前路径描边是否包含指定的点</p>
</li>
</ul>
<h3 id="1-5-绘制文本"><a href="#1-5-绘制文本" class="headerlink" title="1.5. 绘制文本"></a>1.5. 绘制文本</h3><ul>
<li><p><code>ctx.fillText(text, x, y [, maxWidth])</code> 绘制一个位于 (x, y) 的文本，并填充颜色。text 为文本内容。maxWidth 为文本最大宽度，可选项。</p>
</li>
<li><p><code>ctx.strokeText(text, x, y [, maxWidth])</code> 绘制一个位于 (x, y) 的文本，并描边颜色。text 为文本内容。maxWidth 为文本最大宽度，可选项。</p>
</li>
<li><p><code>ctx.measureText(text)</code> 返回 text 的信息，如文字宽度等内容.</p>
</li>
</ul>
<h3 id="1-6-绘制圆和弧"><a href="#1-6-绘制圆和弧" class="headerlink" title="1.6. 绘制圆和弧"></a>1.6. 绘制圆和弧</h3><p>圆周率 π：<code>π = Math.PI ≈ 3.14 = 180°</code>，注意在 canvas 中的角度的表示采用的是弧度制。</p>
<p>例如 30°，在 canvas 中用 <code>30 * Math.PI/180</code> 表示。即：<code>30° = 30 * Math.PI / 180 = Math.PI / 6</code></p>
<ul>
<li><p><code>ctx.arc(x, y, radius, startAngle, endAngle[, anticlockwise])</code> 圆弧路径的圆心在 (x, y) 位置，半径为 r ，根据 anticlockwise （默认为顺时针， true）指定的方向从 startAngle (x 轴方向开始计算) 开始绘制，到 endAngle (圆弧终点) 结束。</p>
</li>
<li><p><code>ctx.arcTo(x1, y1, x2, y2, radius)</code> 根据当前描点(前一个 moveTo 或 lineTo 等函数的止点)与给定的控制点 1 连接的直线，和控制点 1 与控制点 2 连接的直线，作为使用指定半径的圆的切线，画出两条切线之间的弧线路径。</p>
</li>
</ul>
<p><strong>开始角度</strong> 及 <strong>结束角度</strong>：</p>
<p>开始角度和结束角度都是以 x 轴为起点，顺时针环绕。</p>
<p><img src="/images/canvas/arc_angle.png" alt=""></p>
<h3 id="1-7-贝塞尔曲线"><a href="#1-7-贝塞尔曲线" class="headerlink" title="1.7. 贝塞尔曲线"></a>1.7. 贝塞尔曲线</h3><p><a href="https://www.jianshu.com/p/0c9b4b681724" target="_blank" rel="noopener">必须要理解掌握的贝塞尔曲线</a></p>
<ul>
<li><p><code>ctx.quadraticCurveTo(cpx, cpy, x, y)</code> 二次贝塞尔曲线。 需要传入 2 个点，第一个点是控制点，第二个点是终点。起始点是当前路径最新的点，当创建二次贝赛尔曲线之前，可以使用 moveTo() 方法进行改变。即以 3 个点产生一段曲线。</p>
</li>
<li><p><code>ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code> 三次贝塞尔曲线。需要传入 3 个点。 第一、第二个点是控制点，第三个点是结束点。起始点是当前路径的最后一个点，绘制贝赛尔曲线前，可以通过调用 moveTo() 进行修改。即以 4 个点产生一段曲线。</p>
</li>
</ul>
<h3 id="1-8-绘制图像"><a href="#1-8-绘制图像" class="headerlink" title="1.8. 绘制图像"></a>1.8. 绘制图像</h3><ul>
<li><p><code>ctx.drawImage(image[, sx, sy, sWidth, sHeight], dx, dy[, dWidth, dHeight])</code> 在 Canvas 上绘制图像。</p>
<p><strong>image</strong>: 允许 CanvasImageSource 对象，同上。</p>
<p><img src="https://mdn.mozillademos.org/files/225/Canvas_drawimage.jpg" alt=""></p>
<p><strong>dx</strong>：<br>image 的左上角在目标 canvas 上 X 轴坐标。</p>
<p><strong>dy</strong>：<br>image 的左上角在目标 canvas 上 Y 轴坐标。</p>
<p><strong>sx</strong>： 可选参<br>需要绘制到目标上下文中的，image 的矩形（裁剪）选择框的左上角 X 轴坐标。</p>
<p><strong>sy</strong>： 可选参<br>需要绘制到目标上下文中的，image 的矩形（裁剪）选择框的左上角 Y 轴坐标。</p>
<p><strong>sWidth</strong>： 可选参<br>需要绘制到目标上下文中的，image 的矩形（裁剪）选择框的宽度。如果不说明，整个矩形（裁剪）从坐标的 sx 和 sy 开始，到 image 的右下角结束。</p>
<p><strong>sHeight</strong>：可选参<br>需要绘制到目标上下文中的，image 的矩形（裁剪）选择框的高度。</p>
<p><strong>dWidth</strong>：可选<br>image 在目标 canvas 上绘制的宽度。 允许对绘制的 image 进行缩放。 如果不说明， 在绘制时 image 宽度不会缩放。</p>
<p><strong>dHeight</strong>：可选参<br>image 在目标 canvas 上绘制的高度。 允许对绘制的 image 进行缩放。 如果不说明， 在绘制时 image 高度不会缩放。</p>
</li>
</ul>
<h3 id="1-9-变换"><a href="#1-9-变换" class="headerlink" title="1.9. 变换"></a>1.9. 变换</h3><ul>
<li><p><code>ctx.rotate(angle)</code> 传入一个角度，用来旋转画布。旋转方向是顺时针的。旋转中心点是 canvas 的起始点, 默认 x = 0, y = 0。</p>
<p><img src="https://mdn.mozillademos.org/files/233/Canvas_grid_rotate.png" alt=""></p>
</li>
<li><p><code>ctx.scale(x, y)</code> 传入缩放比例来控制画布中的像素单位，x 为水平方向的缩放因子，y 垂直方向的缩放因子。默认情况下，x = 1, y = 1。可以使用 <code>ctx.scale(-1, 1)</code> 水平翻转上下文，使用 <code>ctx.scale(1, -1)</code> 垂直翻转上下文。</p>
</li>
<li><p><code>ctx.translate(x, y)</code> 偏移画布原点。x 水平方向的移动距离, y 垂直方向的移动距离。</p>
<p><img src="https://mdn.mozillademos.org/files/234/Canvas_grid_translate.png" alt=""></p>
</li>
<li><p><code>ctx.transform(a, b, c, d, e, f)</code> 多次叠加当前变换, 即可以缩放、旋转、移动和倾斜上下文。a，水平缩放。b，垂直倾斜。c，水平倾斜。d，垂直缩放。e，水平移动。f，垂直移动。会叠加之前的变换。默认画布配置参数为(1, 0, 0, 1, 0, 0)。即 ad 参数等同 ctx.scale(x, y)，当 ab 参数同时为 0 时，之后的内容不可见；ef 测试等同 ctx.translate(x, y)。bc 参数为 <strong>ctx.transform</strong> 特有，当 bc 参数同时为 1 时，之后的内容不可见。</p>
<p><strong>倾斜角度</strong>：bc 参数数值换算方式，即 tan45° = 1。例如当 b = 1, c = 0 时，将 x 轴方向上倾斜 45 度。</p>
</li>
<li><p><code>ctx.setTransform(a, b, c, d, e, f)</code> 重设当前变换，会覆盖之前的变换。</p>
</li>
</ul>
<h3 id="1-10-像素控制"><a href="#1-10-像素控制" class="headerlink" title="1.10. 像素控制"></a>1.10. 像素控制</h3><ul>
<li><p><code>ctx.createImageData(width, height)</code> 创建一个新的、空白的、指定大小的 ImageData 对象。 所有的像素在新对象中都是透明的。也可传参 <code>imageData</code>。返回一个指定了宽度和高度的，新的 ImageData 对象， 新对象使用透明的像素进行填充。</p>
<p>width：ImageData 新对象的宽度。</p>
<p>height：ImageData 新对象的高度。</p>
<p>imageData：从现有的 ImageData 对象中，复制一个和其宽度和高度相同的对象。图像自身不允许被复制。</p>
</li>
<li><p><code>ctx.getImageData(sx, sy, sw, sh)</code> 返回一个 ImageData 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为 sw、高为 sh。返回一个 ImageData 对象，包含 canvas 给定的矩形图像数据。</p>
</li>
<li><p><code>ctx.putImageData(imageData, dx, dy[, dirtyX, dirtyY, dirtyWidth, dirtyHeight])</code> 将数据从已有的 ImageData 对象绘制到位图的方法。 如果提供了一个绘制过的矩形，则只绘制该矩形的像素。此方法不受画布转换矩阵的影响。</p>
<p>imageData: ImageData ，包含像素值的数组对象。</p>
<p>dx: 源图像数据在目标画布中的 x 轴的坐标位置。</p>
<p>dy: 源图像数据在目标画布中的 y 轴的坐标位置。</p>
<p>dirtyX: 可选, 在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（x 坐标）。</p>
<p>dirtyY: 可选, 在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（y 坐标）。</p>
<p>dirtyWidth: 可选, 在源图像数据中，矩形区域的宽度。默认是图像数据的宽度。</p>
<p>dirtyHeight: 可选, 在源图像数据中，矩形区域的高度。默认是图像数据的高度。</p>
</li>
</ul>
<h3 id="1-11-状态"><a href="#1-11-状态" class="headerlink" title="1.11. 状态"></a>1.11. 状态</h3><ul>
<li><p><code>ctx.save()</code> 将当前状态放入栈中，保存 canvas 全部的状态。</p>
<p><strong>被保存的值</strong>：当前的变换矩阵。当前的剪切区域。当前的虚线列表. 以下属性当前的值： strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled.</p>
</li>
<li><p><code>ctx.restore()</code> 将 canvas 恢复到最近的保存状态的方法。 如果没有保存状态，此方法不做任何改变。</p>
</li>
</ul>
<h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo5" target="_blank" rel="noopener">查看 demo</a></p>
<h2 id="简单动画"><a href="#简单动画" class="headerlink" title="简单动画"></a>简单动画</h2><p>canvas 动画实现原理：使用<code>window.setInterval()</code>或<code>window.setTimeout()</code>或<code>window.requestAnimationFrame()</code>，来清空画布并重绘新一帧的画面。由于肉眼在看超过 24 帧每秒的静态图片就会认为是连续动态视频，所以在这里 1 秒内连续生成 24 帧画面，就会产生连续的动画效果。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo3" target="_blank" rel="noopener">查看 demo</a></p>
<p><strong>帧数</strong>：帧数(Frames)，为帧生成数量的简称。由于口语习惯上的原因，我们通常将帧数与帧率混淆。每一帧都是静止的图象，快速连续地显示帧便形成了运动的假象，因此高的帧率可以得到更流畅、更逼真的动画。</p>
<p><strong>帧率</strong>：帧率(Frame rate)=帧数(Frames)/时间(Time)，单位为帧每秒(f/s, frames per second, fps)。如果一个动画的帧率恒定为 60 帧每秒(fps)，那么它在一秒钟内的帧数为 60 帧，两秒钟内的帧数为 120 帧。</p>
<p><strong>性能</strong>：<code>window.requestAnimationFrame()</code>提供了更加平缓并更加有效率的方式来执行动画，当系统准备好了重绘条件的时候，才调用绘制动画帧。一般使用这个方法来执行动画，比 setInterval、setTimeout 效果更好。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo4" target="_blank" rel="noopener">查看 demo</a></p>
<p><code>window.requestAnimationFrame(callback)</code> 执行动画</p>
<p><code>window.cancelAnimationFrame()</code> 取消动画</p>
<h2 id="设备交互"><a href="#设备交互" class="headerlink" title="设备交互"></a>设备交互</h2><h3 id="1-鼠标事件"><a href="#1-鼠标事件" class="headerlink" title="1. 鼠标事件"></a>1. 鼠标事件</h3><p>Canvas 对象支持所有的 JavaScript 的鼠标事件，包括鼠标点击(MouseClick), 鼠标按下(Mouse Down), 鼠标抬起(Mouse Up), 鼠标移动( Mouse Move)。</p>
<p>添加鼠标事件的两种方式：</p>
<p>1.1. 给 canvas 增加事件监听（推荐）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鼠标移动</span></span><br><span class="line">canvas.addEventListener(<span class="string">'mousemove'</span>, doMouseMove, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标按下</span></span><br><span class="line">canvas.addEventListener(<span class="string">'mousedown'</span>, doMouseDown, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标抬起</span></span><br><span class="line">canvas.addEventListener(<span class="string">'mouseup'</span>, doMouseUp, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标点击</span></span><br><span class="line">canvas.addEventListener(<span class="string">'mouseclick'</span>, doMouseClick, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>1.2. 调用 canvas 自身鼠标事件（反模式，不推荐）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 鼠标移动</span></span><br><span class="line">canvas.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标按下</span></span><br><span class="line">canvas.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标抬起</span></span><br><span class="line">canvas.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标点击</span></span><br><span class="line">canvas.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>1.3. 获取鼠标在 canvas 上的坐标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getPointOnCanvas = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> canvasBox = canvas.getBoundingClientRect()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'canvasBox'</span>, canvasBox)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: x - canvasBox.left * (canvas.width / canvasBox.width),</span><br><span class="line">    y: y - canvasBox.top * (canvas.height / canvasBox.height)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  e =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> mousePoint = getPointOnCanvas(e.x, e.y)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取鼠标在canvas对象上的坐标'</span>, e, mousePoint)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2-键盘事件"><a href="#2-键盘事件" class="headerlink" title="2. 键盘事件"></a>2. 键盘事件</h3><p>HTML5 Canvas 本身不支持键盘事件监听与获取，常用的有两种方法来解决这个问题:</p>
<p>2.1 监听 window 对象的键盘事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'keydown'</span>, doKeyDown, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>2.2 在 Canvas 标签上增加支持键盘事件的 DOM 元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"event_canvas"</span> <span class="attr">tabindex</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">canvas.addEventListener(<span class="string">'keydown'</span>, doKeyDown, <span class="literal">true</span>)</span><br><span class="line">canvas.focus()</span><br></pre></td></tr></table></figure>

<p>其中 <strong>tabindex</strong> 为 HTML5 DOM 元素，支持键盘事件。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo6" target="_blank" rel="noopener">查看 demo</a></p>
<h2 id="高级动画"><a href="#高级动画" class="headerlink" title="高级动画"></a>高级动画</h2><p>高级动画和简单动画的区别，就是我们需要增加一些现实特性，如物理碰撞、加速度、摩擦力、重力作用等等因素，使动画的元素，运动过程中更贴合现实。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo7" target="_blank" rel="noopener">查看 demo</a></p>
<h3 id="1-边界"><a href="#1-边界" class="headerlink" title="1. 边界"></a>1. 边界</h3><h4 id="1-1-设置边界"><a href="#1-1-设置边界" class="headerlink" title="1.1. 设置边界"></a>1.1. 设置边界</h4><p>一般情况下我们把边界设置为 canvas 左上角到右下角，即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> top = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> right = canvas.width</span><br><span class="line"><span class="keyword">let</span> bottom = canvas.height</span><br></pre></td></tr></table></figure>

<p>或者其他参数例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> top = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> left = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> right = canvas.width - <span class="number">50</span></span><br><span class="line"><span class="keyword">let</span> bottom = canvas.height - <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>当设置好边界之后，即可对小球超出边界后进行其他操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ball.x &gt; right) &#123;</span><br><span class="line">  <span class="comment">// to do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ball.x &lt; left) &#123;</span><br><span class="line">  <span class="comment">// to do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ball.y &gt; bottom) &#123;</span><br><span class="line">  <span class="comment">// to do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ball.y &lt; top) &#123;</span><br><span class="line">  <span class="comment">// to do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-超出边界移除"><a href="#1-2-超出边界移除" class="headerlink" title="1.2. 超出边界移除"></a>1.2. 超出边界移除</h4><p>效果：若干小球朝不同的方向移动，当某小球超出边界即不再显示这个小球，直到画面上全部小球消失。</p>
<p>原理：生成若干小球 push 到数组里，当某小球超出边界时，通过 id 删除数组中该小球的数据，即下次渲染帧时，不会再渲染该小球。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo8" target="_blank" rel="noopener">查看 demo 超出边界移除</a></p>
<h4 id="1-3-超出边界重新形成"><a href="#1-3-超出边界重新形成" class="headerlink" title="1.3. 超出边界重新形成"></a>1.3. 超出边界重新形成</h4><p>效果：若干小球朝不同的方向移动，当小球超出边界时，重新再指定位置出现，并不断移动。</p>
<p>原理：生成若干小球 push 到数组里，当某小球超出边界时，重置数组中该小球的位置即可。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo9" target="_blank" rel="noopener">查看 demo 超出边界重新形成</a></p>
<h4 id="1-4-边界环绕"><a href="#1-4-边界环绕" class="headerlink" title="1.4. 边界环绕"></a>1.4. 边界环绕</h4><p>效果：若干小球朝不同的方向移动，当小球超出边界时，小球从反方向的边界出现，并不断移动。例：小球从右往左移动，当小球超出左边界时，小球重新出现在右边界，并继续往左移动。</p>
<p>原理：生成若干小球 push 到数组里，当某小球超出任意边界时，数组中该小球的位置取边界的反值即可。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo10" target="_blank" rel="noopener">查看 demo 边界环绕</a></p>
<h4 id="1-5-边界反弹"><a href="#1-5-边界反弹" class="headerlink" title="1.5. 边界反弹"></a>1.5. 边界反弹</h4><p>效果：若干小球朝不同的方向移动，当小球超出边界时，小球往该边界的反方向的移动。</p>
<p>原理：生成若干小球 push 到数组里，当某小球超出任意边界时，数组中该小球的加速度取反即可。如果需要模拟现实中的重力加速度，则使 vy 衰减即可。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo11" target="_blank" rel="noopener">查看 demo 边界反弹</a></p>
<h3 id="2-速度、加速度和重力加速度"><a href="#2-速度、加速度和重力加速度" class="headerlink" title="2. 速度、加速度和重力加速度"></a>2. 速度、加速度和重力加速度</h3><p><strong>速度</strong>，描述物体运动快慢和方向的物理量。在 canvas 中速度是矢量的，既有大小又有方向，而方向的体现就是其值的正负。任何一个速度都可以分解为 x 轴和 y 轴上的速度。</p>
<p><strong>加速度</strong>，即速率，是描述物体速度变化快慢的物理量。加速度的方向与速度相同即加速，方向相反即减速，如果加速度为零，速度将恒定，物体做匀速直线运动。</p>
<p><img src="/images/canvas/speed.png" alt=""></p>
<p><code>vx = speed * Math.cos(angle)</code></p>
<p><code>vy = speed * Math.sin(angle)</code></p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo16" target="_blank" rel="noopener">查看 demo 匀速运动和加速度运动</a></p>
<p><strong>重力加速度</strong>，重力对自由下落的物体产生的加速度。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo17" target="_blank" rel="noopener">查看 demo 重力加速度</a></p>
<h3 id="3-摩擦力"><a href="#3-摩擦力" class="headerlink" title="3. 摩擦力"></a>3. 摩擦力</h3><p>两个相互接触并挤压的物体，当它们发生相对运动或具有相对运动趋势时，就会在接触面上产生阻碍相对运动或相对运动趋势的力，这种力叫做<strong>摩擦力</strong>。通常我们用字母 <code>f</code> 来表示摩擦力。</p>
<p>通俗的说，就是一个物体的速度，因为摩擦力的影响，会不断的发生衰减，直到速度为 0 时，物体也停止了运动。</p>
<ul>
<li><p>计算物体运动的角度 <code>angle = Math.atan2(vy, vx)</code></p>
</li>
<li><p>计算物体运动的速度 <code>speed = Math.sqrt(vx*vx + vy*vy)</code></p>
</li>
</ul>
<p>当速度大于摩擦力时，将速度减去摩擦力，得到一个衰减后的速度值，然后再使用加速度计算公式，算出新速度的 vx 和 vy 的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (speed &gt; f) &#123;</span><br><span class="line">  speed -= f</span><br><span class="line">  vx = <span class="built_in">Math</span>.cos(angle) * speed</span><br><span class="line">  vy = <span class="built_in">Math</span>.sin(angle) * speed</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  speed = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo18" target="_blank" rel="noopener">查看 demo 摩擦力</a></p>
<h3 id="4-拖尾效果"><a href="#4-拖尾效果" class="headerlink" title="4. 拖尾效果"></a>4. 拖尾效果</h3><p>拖尾效果常用于绘制流星和烟花等动画。顾名思义，就是物体运动时会有一个尾巴跟随。</p>
<p>最简单的拖尾效果实现方案，使用以下代码代替 <code>clear</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ctx.fillStyle=<span class="string">"rgba(0,0,0,0.2)"</span></span><br><span class="line">ctx.rect(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line">ctx.fill();</span><br></pre></td></tr></table></figure>
<p>原理是每帧画面加上一个透明度为0.2的蒙层，随着蒙层叠加的层数越多，较底层的图层也被覆盖到看不见了，以此而形成了拖尾效果。</p>
<h3 id="5-物理碰撞"><a href="#5-物理碰撞" class="headerlink" title="5. 物理碰撞"></a>5. 物理碰撞</h3><h4 id="5-1-分离轴定理"><a href="#5-1-分离轴定理" class="headerlink" title="5.1 分离轴定理"></a>5.1 分离轴定理</h4><h4 id="5-2-最小平移向量"><a href="#5-2-最小平移向量" class="headerlink" title="5.2 最小平移向量"></a>5.2 最小平移向量</h4><p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo18" target="_blank" rel="noopener">查看 demo 拖拽抛扔</a></p>
<h3 id="6-缓动动画"><a href="#6-缓动动画" class="headerlink" title="6. 缓动动画"></a>6. 缓动动画</h3><p>物体由以低速开始，然后加快，在结束前变慢的滑行到目标位置，然后停止。类似于<strong>CSS</strong>中的<code>animation-timing-function: ease</code>效果。</p>
<h3 id="7-弹性动画"><a href="#7-弹性动画" class="headerlink" title="7. 弹性动画"></a>7. 弹性动画</h3><p>物体运动到目标位置之后，并不会立刻停止，而是以目标位置为中心点做一个类似弹簧的往复运动，其速度不断衰减，最终会停止在目标位置。</p>
<h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><p>在绘制 canvas 时，经常需要进行各种数值计算，除了简单的加减乘除，要实现更复杂的效果往往需要使用到三角函数、圆周率等数学概念，还需要理解摩擦力、加速度等物理概念。</p>
<h3 id="1-三角函数"><a href="#1-三角函数" class="headerlink" title="1. 三角函数"></a>1. 三角函数</h3><p><code>π = Math.PI ≈ 3.14 = 180°</code></p>
<p>常见的三角函数包括正弦函数、余弦函数和正切函数。</p>
<p><img src="/images/canvas/cossincot.png" alt=""></p>
<p>通过夹角，计算边：</p>
<ul>
<li><p><strong>sin(θ) = X / R</strong> → <code>Math.sin( θ * Math.PI / 180 )</code></p>
</li>
<li><p><strong>cos(θ) = Y / R</strong> → <code>Math.cos( θ * Math.PI / 180 )</code></p>
</li>
<li><p><strong>tan(θ) = X / Y</strong> → <code>Math.tan( θ * Math.PI / 180 )</code></p>
</li>
</ul>
<p>通过边，计算夹角：</p>
<ul>
<li><p><strong>θ = arcsin(X / R)</strong> → <code>Math.asin(X / R) * (180 / Math.PI)</code></p>
</li>
<li><p><strong>θ = arccos(Y / R)</strong> → <code>Math.acos(Y / R) * (180 / Math.PI)</code></p>
</li>
<li><p><strong>θ = arctan(X / Y)</strong> → <code>Math.atan(X / Y) * (180 / Math.PI)</code></p>
</li>
</ul>
<p><strong>Math.atan</strong> 有一个缺陷，就是无法获取角度的方向。我们指定坐标轴有四个象限：<code>X / Y = -X / -Y</code>，<code>-X / Y = X / Y</code>。</p>
<p><img src="/images/canvas/atant.png" alt=""></p>
<p>即在 Math.atan 计算中, A、B、C、D 的值是相等的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A = <span class="built_in">Math</span>.atan(<span class="number">2</span> / <span class="number">1</span>) * ((<span class="number">26.57</span> * <span class="built_in">Math</span>.PI) / <span class="number">180</span>)</span><br><span class="line"><span class="keyword">const</span> B = <span class="built_in">Math</span>.atan(<span class="number">-2</span> / <span class="number">1</span>) * ((<span class="number">-26.57</span> * <span class="built_in">Math</span>.PI) / <span class="number">180</span>)</span><br><span class="line"><span class="keyword">const</span> C = <span class="built_in">Math</span>.atan(<span class="number">-2</span> / <span class="number">-1</span>) * ((<span class="number">26.57</span> * <span class="built_in">Math</span>.PI) / <span class="number">180</span>)</span><br><span class="line"><span class="keyword">const</span> D = <span class="built_in">Math</span>.atan(<span class="number">2</span> / <span class="number">-1</span>) * ((<span class="number">-26.57</span> * <span class="built_in">Math</span>.PI) / <span class="number">180</span>)</span><br><span class="line"><span class="built_in">console</span>.log(A, B, C, D)</span><br><span class="line"><span class="comment">// 0.5134224838510526 0.5134224838510526 0.5134224838510526 0.5134224838510526</span></span><br></pre></td></tr></table></figure>

<p>因此当我们需要获取角度的方向时，可以使用<code>Math.atan2(dy, dx)</code>来计算：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> A2 = <span class="built_in">Math</span>.atan2(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> B2 = <span class="built_in">Math</span>.atan2(<span class="number">-2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> C2 = <span class="built_in">Math</span>.atan2(<span class="number">-2</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">const</span> D2 = <span class="built_in">Math</span>.atan2(<span class="number">2</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(A2, B2, C2, D2)</span><br><span class="line"><span class="comment">// 1.1071487177940904 -1.1071487177940904 -2.0344439357957027 2.0344439357957027</span></span><br></pre></td></tr></table></figure>

<p>由于 <strong>Math.atan</strong> 的弊端，使用<code>Math.atan2(dy, dx)</code>来代替 Math.atan 计算角度即可。</p>
<p><strong>特殊角的值</strong>：</p>
<p><code>Math.sqrt()</code> 计算平方根。注意：tan90° 不存在。</p>
<table>
<thead>
<tr>
<th align="center">角度</th>
<th align="center">0°</th>
<th align="center">15°</th>
<th align="center">30°</th>
<th align="center">45°</th>
<th align="center">60°</th>
<th align="center">90°</th>
<th align="center">120°</th>
<th align="center">135°</th>
<th align="center">150°</th>
<th align="center">180°</th>
<th align="center">270°</th>
</tr>
</thead>
<tbody><tr>
<td align="center">弧度</td>
<td align="center">0</td>
<td align="center">π/12</td>
<td align="center">π/6</td>
<td align="center">π/4</td>
<td align="center">π/3</td>
<td align="center">π/2</td>
<td align="center">2π/3</td>
<td align="center">3π/4</td>
<td align="center">5π/6</td>
<td align="center">π</td>
<td align="center">3π/2</td>
</tr>
<tr>
<td align="center">sin 值</td>
<td align="center">0</td>
<td align="center">[（√6）-（√2）]/4</td>
<td align="center">1/2</td>
<td align="center">（√2）/2</td>
<td align="center">（√3）/2</td>
<td align="center">1</td>
<td align="center">（√3）/2</td>
<td align="center">（√2）/2</td>
<td align="center">1/2</td>
<td align="center">0</td>
<td align="center">-1</td>
</tr>
<tr>
<td align="center">cos 值</td>
<td align="center">1</td>
<td align="center">[（√6）+（√2）]/4</td>
<td align="center">（√3）/2</td>
<td align="center">（√2）/2</td>
<td align="center">1/2</td>
<td align="center">0</td>
<td align="center">-1/2</td>
<td align="center">-（√2）/2</td>
<td align="center">-（√3）/2</td>
<td align="center">-1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">tan 值</td>
<td align="center">0</td>
<td align="center">2-√3</td>
<td align="center">（√3）/3</td>
<td align="center">1</td>
<td align="center">√3</td>
<td align="center">∅</td>
<td align="center">-√3</td>
<td align="center">-1</td>
<td align="center">-（√3）/3</td>
<td align="center">0</td>
<td align="center">∅</td>
</tr>
<tr>
<td align="center">cot 值</td>
<td align="center">∅</td>
<td align="center">2+√3</td>
<td align="center">√3</td>
<td align="center">1</td>
<td align="center">√3/3</td>
<td align="center">0</td>
<td align="center">-（√3）/3</td>
<td align="center">-1</td>
<td align="center">-√3</td>
<td align="center">∅</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo12" target="_blank" rel="noopener">查看 demo 鼠标跟随</a></p>
<h3 id="2-波形运动"><a href="#2-波形运动" class="headerlink" title="2. 波形运动"></a>2. 波形运动</h3><p>凡质地柔软的物体由于力的作用，从受力点一端向另一端推移，就产生波形的曲线运动，曲线运动都是反复循环的。波形图像，又叫做正弦曲线。</p>
<p>即使用 <code>Math.sin(angle)</code> 计算，我们可以绘制出十分自然的波形运动动画。计算出的值，在[-1, 1]的区间中逐步递增或逐步衰减，一直循环下去。</p>
<p>例：[0.1, 0.2, …… 0.8, 0.9, 0.8 …… 0.2, 0.1, -0.1, -0.2 …… -0.9, -0.8 …… -0.1, 0.1, 0.2]</p>
<p>因此，当我们需要绘制一个循环反复的动画运动效果时，可以使用 <code>Math.sin(angle)</code> 来计算动画变换的值。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo14" target="_blank" rel="noopener">查看 demo 曲线球</a></p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo15" target="_blank" rel="noopener">查看 demo 脉冲球</a></p>
<p><a href="https://gaofanghuang.github.io/demo/api/canvas/demo13" target="_blank" rel="noopener">查看 demo 水草摆动</a></p>
<h2 id="运动规律"><a href="#运动规律" class="headerlink" title="运动规律"></a>运动规律</h2><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol>
<li><p>在离屏 canvas 上预渲染相似的图形或重复的对象。</p>
</li>
<li><p>避免浮点数的坐标点，用整数取而代之。用 Math.floor() 函数对所有的坐标点取整。</p>
</li>
<li><p>不要在用 drawImage 时缩放图像。在离屏 canvas 中缓存图片的不同尺寸，而不要用 drawImage() 去缩放它们。</p>
</li>
<li><p>使用多层画布去画一个复杂的场景。</p>
</li>
<li><p>用 CSS 设置大的背景图。</p>
</li>
<li><p>用 CSS transforms 特性缩放画布。</p>
</li>
<li><p>关闭透明度。<code>var ctx = canvas.getContext(&#39;2d&#39;, { alpha: false });</code></p>
</li>
<li><p>将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）。</p>
</li>
<li><p>避免不必要的画布状态改变。</p>
</li>
<li><p>渲染画布中的不同点，而非整个新状态。</p>
</li>
<li><p>尽可能避免 shadowBlur 特性。</p>
</li>
<li><p>尽可能避免 text rendering。</p>
</li>
<li><p>使用不同的办法去清除画布(clearRect() vs. fillRect() vs. 调整 canvas 大小)。</p>
</li>
<li><p>有动画，请使用 window.requestAnimationFrame() 而非 window.setInterval()。</p>
</li>
<li><p>请谨慎使用大型物理库。</p>
</li>
</ol>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><ol>
<li><a href="/">音乐播放器</a></li>
</ol>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ol>
<li><p>标签需要闭合，<code>&lt;canvas&gt;</code> 元素需要有闭合标签 (<code>&lt;/canvas&gt;</code>)。</p>
</li>
<li><p>设置画布( canvas )的大小</p>
</li>
</ol>
<p>可以直接在 html 标签中使用 width 和 height 属性 或 css 来设置画布尺寸，canvas 会通过放大缩小图像来适应画布。需要注意的是，这样容易造成图像内容模糊变形，我们目前无法使用 css 的样式来控制变形，如<code>object-fit:cover</code>，目前只能用改变宽高属性实现。</p>
<p>推荐的方法是宽高直接写在 canvas 标签上，或者使用 js 来修改 canvas 的宽高。</p>
<ol start="3">
<li>canvas 标签内的内容，当 canvas 工作时并不会显示，而当浏览器不支持 canvas 时，才会显示。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">  抱歉，您的浏览器不支持canvas元素 （这些内容将会在不支持 canvas</span><br><span class="line">  元素的浏览器或是禁用了 JavaScript 的浏览器内渲染并展现）</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>canvas 画布清空问题</li>
</ol>
<p>清除 Canvas 任意区域像素可以用 canvas_context.clearRect(x, y, width, height)，但如果只有一个 Canvas，不同的方法都调用同一个 Canvas 时，只调用 canvas_context.clearRect(x, y, width, height)之后，再次绘制会出现偏移现象。</p>
<p>此时只要重置画布的宽度或者高度<code>canvas.width = canvas.width</code>，canvas 标签就会重新被渲染，以此达到完全清空画布内容的效果。</p>
<ol start="5">
<li>ctx.font 不生效</li>
</ol>
<p>ctx.font 必须同时设置 字体大小 和 字体名称， 如设置 <code>ctx.font = &#39;16px&#39;</code> 时是无效的，必须加上 font-family 才行, 即：<code>ctx.font = &#39;16px serif&#39;</code></p>
<ol start="6">
<li>引用外部图片资源绘制，toDataUrl()报错：Uncaught DOMException: Failed to execute ‘toDataURL’ on ‘HTMLCanvasElement’: Tainted canvases may not be exported.</li>
</ol>
<p>解决方案：</p>
<p>① 把图片移动到当前域下。</p>
<p>② 服务器允许跨域，并且 img 设置允许跨域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.setAttribute(<span class="string">'crossOrigin'</span>, <span class="string">'anonymous'</span>)</span><br><span class="line">img.src = url</span><br></pre></td></tr></table></figure>

<h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/tabindex" target="_blank" rel="noopener">tabindex</a></li>
</ol>
<blockquote>
<p>tabindex 全局属性 指示其元素是否可以聚焦，以及它是否/在何处参与顺序键盘导航（通常使用 Tab 键，因此得名）。</p>
</blockquote>
<ol start="2">
<li><a href="https://huanggaofang.com/2020/keycode/">keycode 键位表</a></li>
</ol>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
        <tag>Html</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>【开发中】Gameshell for web</title>
    <url>/2020/gameshell/</url>
    <content><![CDATA[<p>gameshell</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Game</tag>
        <tag>Gameshell</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>【开发中】carrotdaily</title>
    <url>/2020/carrotdaily/</url>
    <content><![CDATA[<p>carrotdaily sds</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>Expo</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>【开发中】saltedfish</title>
    <url>/2020/saltedfish/</url>
    <content><![CDATA[<p>saltedfish22</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Ionic</tag>
        <tag>Typescript</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/promise/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="1-Async"><a href="#1-Async" class="headerlink" title="1. Async"></a>1. Async</h3><p>async function 用来定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。</p>
<h3 id="2-Await"><a href="#2-Await" class="headerlink" title="2. Await"></a>2. Await</h3><p>异步函数可以包含 await 指令，该指令会暂停异步函数的执行，并等待 Promise 执行，然后继续执行异步函数，并返回结果。</p>
<p>await 关键字只在异步函数内有效。如果在异步函数外使用它，会抛出语法错误。</p>
<p>当异步函数暂停时，它调用的函数会继续执行(收到异步函数返回的隐式 Promise)</p>
<h3 id="3-Promise"><a href="#3-Promise" class="headerlink" title="3. Promise"></a>3. Promise</h3><p>Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值.</p>
<a id="more"></a>

<h4 id="Async-Await-和-Promise-的关系"><a href="#Async-Await-和-Promise-的关系" class="headerlink" title="Async/Await 和 Promise 的关系"></a>Async/Await 和 Promise 的关系</h4><p>async/await 的目的是简化使用多个 promise 时的同步行为，并对一组 Promises 执行某些操作。正如 Promises 类似于结构化回调，async/await 更像结合了 generators 和 promises。</p>
<p>大多数异步函数也可以使用 Promises 编写。</p>
<h4 id="Async-Await-和-Promise-的区别"><a href="#Async-Await-和-Promise-的区别" class="headerlink" title="Async/Await 和 Promise 的区别"></a>Async/Await 和 Promise 的区别</h4><p>在错误处理方面，async 函数更容易捕获异常错误。</p>
<h4 id="回调函数和-Promise-的区别"><a href="#回调函数和-Promise-的区别" class="headerlink" title="回调函数和 Promise 的区别"></a>回调函数和 Promise 的区别</h4><p>回调函数容易造成回调地狱。promise 可以让代码更容易读懂。</p>
<p>回调函数：</p>
<p>把一个函数 A 传给另一个函数 B 调用，并在函数 B 完成后执行，那么 A 就是回调函数。</p>
<p><a href="https://gaofanghuang.github.io/demo/api/promise/demo4" target="_blank" rel="noopener">查看 demo</a></p>
<h3 id="4-bluebird"><a href="#4-bluebird" class="headerlink" title="4. bluebird"></a>4. bluebird</h3><p>bluebird 是一个第三方 Promise 规范实现库，它不仅完全兼容原生 Promise 对象，且比原生对象功能更强大。bluebird 的浏览器兼容性比原生的更好。</p>
<p><a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="noopener">bluebird api 文档</a></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="1-Async-1"><a href="#1-Async-1" class="headerlink" title="1. Async"></a>1. Async</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>name 函数名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>param 要传递给函数的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>statements 函数体语句</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">[param[, param[, ... param]]]</span>) </span>&#123; statements &#125;</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<p>返回的 Promise 对象会运行<strong>执行</strong>(resolve)异步函数的返回结果，或者运行<strong>拒绝</strong>(reject)——如果异步函数抛出异常的话。</p>
<h3 id="2-Await-1"><a href="#2-Await-1" class="headerlink" title="2. Await"></a>2. Await</h3><p><code>[return_value] = await expression;</code></p>
<p><strong>expression</strong> 表达式:</p>
<p>一个 Promise 对象或者任何要等待的值。</p>
<p><strong>return_value</strong> 返回值:</p>
<p>返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p>
<h3 id="3-Promise-1"><a href="#3-Promise-1" class="headerlink" title="3. Promise"></a>3. Promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@params </span>resolve 将promise的状态改为fulfilled（完成）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@prams </span>reject 将promise的状态改为rejected（失败）</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125; <span class="comment">/* executor */</span>  );</span><br></pre></td></tr></table></figure>

<p>如果在 executor 函数中抛出一个错误，那么该 promise 状态为 rejected。 executor 函数的返回值被忽略。</p>
<p>一个 Promise 有以下几种状态：</p>
<ul>
<li><p>pending: 初始状态，既不是成功，也不是失败状态。</p>
</li>
<li><p>fulfilled: 意味着操作成功完成。</p>
</li>
<li><p>rejected: 意味着操作失败。</p>
</li>
</ul>
<p>状态变化过程（from MDN）:</p>
<p><img src="https://mdn.mozillademos.org/files/8633/promises.png" alt=""></p>
<p>方法：</p>
<ul>
<li><p><code>Promise.all(iterable)</code>: 返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。 Promise.all 方法常被用于处理多个 promise 对象的状态集合。</p>
</li>
<li><p><code>Promise.race(iterable)</code>: 当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象。</p>
</li>
<li><p><code>Promise.reject(reason)</code>: 返回一个状态为失败的 Promise 对象，并将给定的失败信息传递给对应的处理方法。注意当使用 reject 之后，必须要加 catch 声明 onRejected 回调。</p>
</li>
<li><p><code>Promise.resolve(value)</code>: 返回一个状态由给定 value 决定的 Promise 对象。如果该值是 thenable (即，带有 then 方法的对象)，返回的 Promise 对象的最终状态由 then 方法执行决定；否则的话(该 value 为空，基本类型或者不带 then 方法的对象)，返回的 Promise 对象状态为 fulfilled，并且将该 value 传递给对应的 then 方法。</p>
</li>
</ul>
<p>Promise 原型方法：</p>
<ul>
<li><p><code>Promise.prototype.catch(onRejected)</code>：添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的 promise。当这个回调函数被调用，新 promise 将以它的返回值来 resolve，否则如果当前 promise 进入 fulfilled 状态，则以当前 promise 的完成结果作为新 promise 的完成结果。</p>
</li>
<li><p><code>Promise.prototype.then(onFulfilled, onRejected)</code>：添加<strong>解决</strong>(fulfillment)和<strong>拒绝</strong>(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来 resolve。</p>
</li>
<li><p><code>Promise.prototype.finally(onFinally)</code>：不管最终返回的是 resolve 还是 reject, finally 里的代码都会执行，一般写在 catch 后面。</p>
</li>
</ul>
<p>Tips:</p>
<ol>
<li><p>写 promise 最好加上 catch。</p>
</li>
<li><p>由于 promise 是异步的, try catch 语句也无法捕获其错误。</p>
</li>
</ol>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="1-创建一个-promise"><a href="#1-创建一个-promise" class="headerlink" title="1. 创建一个 promise"></a>1. 创建一个 promise</h3><p><a href="https://gaofanghuang.github.io/demo/api/promise/demo1" target="_blank" rel="noopener">查看 demo</a></p>
<h3 id="2-使用-async-函数重写-promise-链"><a href="#2-使用-async-函数重写-promise-链" class="headerlink" title="2. 使用 async 函数重写 promise 链"></a>2. 使用 async 函数重写 promise 链</h3><p><a href="https://gaofanghuang.github.io/demo/api/promise/demo2" target="_blank" rel="noopener">查看 demo</a></p>
<h3 id="3-多个-promise-同时执行"><a href="#3-多个-promise-同时执行" class="headerlink" title="3. 多个 promise 同时执行"></a>3. 多个 promise 同时执行</h3><p><a href="https://gaofanghuang.github.io/demo/api/promise/demo3" target="_blank" rel="noopener">查看 demo</a></p>
<h3 id="4-Promise-和-this-指向"><a href="#4-Promise-和-this-指向" class="headerlink" title="4. Promise 和 this 指向"></a>4. Promise 和 this 指向</h3><p><a href="https://gaofanghuang.github.io/demo/api/promise/demo5" target="_blank" rel="noopener">查看 demo</a></p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="1-Uncaught-in-promise-报错"><a href="#1-Uncaught-in-promise-报错" class="headerlink" title="1. Uncaught (in promise) 报错"></a>1. Uncaught (in promise) 报错</h3><p>promise 上必须加上 <code>.catch((e) =&gt; {})</code>。 如果使用 async/await, 则需要使用 <code>try {...} catch {...}</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; promise 错误写法</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    const res &#x3D; &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回 0 或 1</span><br><span class="line">      code</span><br><span class="line">    &#125;</span><br><span class="line">    if (res.code) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回一个成功结果</span><br><span class="line">      resolve(&#39;[code is 1]&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回一个失败结果</span><br><span class="line">      reject(&#39;[code is not 1]&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; async&#x2F;await 错误写法</span><br><span class="line">const doAsync2 &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;执行 async 方法2&#39;, new Date().getTime())</span><br><span class="line">  const res &#x3D; await todoSth()</span><br><span class="line">  console.log(&#39;成功2&#39;, res, new Date().getTime())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; promise 正确写法</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    const res &#x3D; &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回 0 或 1</span><br><span class="line">      code</span><br><span class="line">    &#125;</span><br><span class="line">    if (res.code) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回一个成功结果</span><br><span class="line">      resolve(&#39;[code is 1]&#39;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回一个失败结果</span><br><span class="line">      reject(&#39;[code is not 1]&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; async&#x2F;await 正确写法</span><br><span class="line">const doAsync &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;执行 async 方法&#39;, new Date().getTime())</span><br><span class="line">  try &#123;</span><br><span class="line">    const res &#x3D; await todoSth()</span><br><span class="line">    console.log(&#39;成功&#39;, res, new Date().getTime())</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(&#39;失败&#39;, err, new Date().getTime())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-重复的-catch，一个-promise-只需要一个-catch"><a href="#2-重复的-catch，一个-promise-只需要一个-catch" class="headerlink" title="2. 重复的 catch，一个 promise 只需要一个 catch"></a>2. 重复的 catch，一个 promise 只需要一个 catch</h3><p>当同一个 promise 上 then 里调用了 err 和 链式调用了 catch 时，错误只会在 err 中被捕获， catch 中的代码是不会被执行的。</p>
<p>如果 一个 promise 里 还有嵌套 promise, 那么只需要在最外层的 promise 加上 catch。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确写法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法1</span><br><span class="line">todoSth()</span><br><span class="line">  .then(res &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;成功&#39;, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(err &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;失败&#39;, err)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">todoSth().then(</span><br><span class="line">    res &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;成功&#39;, res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;失败&#39;, err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误写法</span><br><span class="line">todoSth().then(</span><br><span class="line">    res &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;成功&#39;, res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;失败&#39;, err)</span><br><span class="line">    &#125;</span><br><span class="line">  ).catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;失败2&#39;, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="3-then-和-catch-执行顺序问题"><a href="#3-then-和-catch-执行顺序问题" class="headerlink" title="3. then 和 catch 执行顺序问题"></a>3. then 和 catch 执行顺序问题</h3><p>当 catch 写在 then 前时，then 中的代码也会被执行，但是 <code>res = undefined</code>。因此，catch 应该写在链式调用的最后部分。</p>
<p>多个 then 时，前面 then 报错会阻塞后面 then 中代码的执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误写法</span><br><span class="line">todoSth().catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;失败&#39;, err)</span><br><span class="line">  &#125;).then(</span><br><span class="line">    res &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;成功&#39;, res)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确写法</span><br><span class="line">todoSth().then(</span><br><span class="line">    res &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;成功&#39;, res)</span><br><span class="line">    &#125;</span><br><span class="line">  ).catch(err &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;失败&#39;, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Promise</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog Init</title>
    <url>/2020/init/</url>
    <content><![CDATA[<p>前段时间体验了两个月阿里云服务器，自己用Node搭后端服务、做CMS后台管理系统，运维部署，还是学到蛮多东西的。</p>
<p>不过还是不想花太多时间在建站维护上了，后端涉及的东西太多了感觉头大，网络安全、数据库管理啊什么的，所以还是回归hexo吧。</p>
<p>多出的时间想学点感兴趣的新东西，着重研究图形和视觉方面的技术：canvas、webGl、three、vr、ar等等。</p>
<p>这周把 MDN 的 canvas 教程又过了一遍，然后每个知识点自己撸了遍 demo, 对 api 的理解又加深了一丢丢😄</p>
<p>接下来准备用 canvas 做一些更复杂的案例啦，加油吧~</p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>流水账</tag>
      </tags>
  </entry>
</search>
